using System;
using System.Text;
using System.Drawing;
using System.Collections;
using System.Diagnostics;
using System.Windows.Forms;

namespace CommandAS.Tools
{
	/// <summary>
	/// Summary description for clsRtf2Html.
	/// </summary>
	public class clsRtf2Html
	{
		public enum TMode
		{
			c_modRTF2HTML,
			c_modHTML2RTF
		}

		#region Vars

		private const string m_Comment=@"Generated by Rtf2Html from AndryC";
		private const string constHTTP=@"http:&DateTimeLabelUniqueValue";
		private string m_strName; //!< Name of node (primary attribute/RTF Tag)
		private string m_strCode; //!< The node's whole code (with sub-nodes)
		private string m_strThisCode; //!< the nodes code (without sub-nodes)
		private string m_strPlain; //!< The nodes plain text (without sub-nodes and attributes/RTF Tags)
		private string m_strLang;	//строка, определяющая кодировка блока RTF

		//! RTF Code
		protected string m_strRTF;
		//! HTML Code
		protected string m_strHTML;
		//! The title of the document
		protected string m_strTitle;
		//! Charset/Codepage of the document
		protected string m_strCharset;
		//! Conversion direction (RTF<->HTML)
		protected TMode   m_enMode;
		//по умолчанию цвет
		protected string m_strActColor;
		//! Internal RTF Tree
		/*! Each matching {} is a tree node. See CRTFNodeA for details*/
		private CRTFNode m_RTFTree;
		//! Parser actual font size
		private string m_strActFontSize;
		//! Parser actual font name
		private string m_strActFontName;
		//! Parser actual color
		private string m_strActFontColor;
		//! Font map table
		/*! Key: String(Font-Designator), e.g. "f0", "f1", ... -> Value: Font Name, e.g. "Arial", "Courier" */
		ArrayList m_mapFontNames; //CMapStringToString[]
		//! Array of colors (palette)
		/*! Colors do not have name (like fonts: "f0"), they are just sequentially ordered in a color table*/
		ArrayList m_arrColors; //Color
		//! Array of created html nodes
		ArrayList m_arrHTMLElements; //CHTMLElement[]

		#endregion

		#region Construction/Destruction
		public clsRtf2Html():this(TMode.c_modRTF2HTML){}
		/// <summary>
		/// /Add constructor logic here
		/// </summary>
		/// <param name="enMode"></param>
		public clsRtf2Html(TMode enMode)
		{
			Debug.Assert(enMode==TMode.c_modRTF2HTML); //vice versa unsupported at the moment
			m_enMode = enMode;
			m_RTFTree = new CRTFNode();
			SetTitle  = "RTF2HTML Generated Document";
			m_arrColors=new ArrayList();				//Color[]
			m_arrHTMLElements=new ArrayList();	//CHTMLElement[]
			m_mapFontNames=new ArrayList();			//CMapStringToString[]
			m_RTFTree=new CRTFNode();

			m_strName=string.Empty;
			m_strCode=string.Empty;
			m_strThisCode=string.Empty;
			m_strPlain=string.Empty;
			m_strLang=string.Empty;

			ResetMetaData();
		}
		~clsRtf2Html()
		{
			m_RTFTree=null;
		}
		#endregion
		
		#region Более-менее рабочие ф-ции

		string SetTitle
		{
			get
			{
				return m_strTitle;
			}
			set
			{
				m_strTitle = value;
			}
		}
		void ResetMetaData()
		{
			m_strCharset = "1251";
			m_strActFontColor = "#000000";
			m_strActFontName = "Times New Roman";
			m_strActFontSize = "10";
			m_strActColor = "#000000";
			m_mapFontNames.Clear();
			m_arrColors.Clear();
			m_arrHTMLElements.Clear();
		}
		public string ConvertRTF2HTML(ref string source)
		{
#if DEBUG
			System.IO.StreamWriter sw=new System.IO.StreamWriter(@"c:\temp\_123Rtf.rtf");
			sw.Write(source);
			sw.Flush();
			sw.Close();
#endif
			//Initializing
			m_strHTML = string.Empty;
			m_strRTF=source;

			//Check_Valid_RTF
			m_strRTF=m_strRTF.TrimEnd('\n'); //m_strRTF.TrimRight("\n");
			m_strRTF=m_strRTF.TrimEnd('\r'); //m_strRTF.TrimRight("\r");
			m_strRTF=m_strRTF.Replace(@"_\v &_\v0"," "); //старое наследие RTF - это пробел между словами в гиперссылке
			//m_strRTF=m_strRTF.Replace("&_"," "); //старое наследие RTF

			//string strEndChar=m_strRTF.Substring(m_strRTF.Length-1,1);   
			if (!(m_strRTF.Length>=7 && m_strRTF.Substring(0,6)=="{\\rtf1") && m_strRTF.LastIndexOf("}")==-1)
			{
				//Invalid RTF file. Must start with "{RTF1" and end with "}"
				Debug.Assert(false,"Not right RTF","header or footer this message RTF not valid !");
				return m_strHTML;
			}

			//Clear internal members
			ResetMetaData();

			//Build up RTF Tree. Each tree in a node coresponds to a {} section in the RTF file (code)
			//and has a designator (name), like \RTF or \FONTTBL. We start with the whole RTF file
			//(Section \RTF1)  
			m_RTFTree = new CRTFNode();
			CRTFNode NodeRoot = R2H_BuildTree(m_strRTF,ref m_RTFTree);

			string strRTFCode = NodeRoot.m_strThisCode;

			//Fill internal meta data members
			R2H_SetMetaData(ref NodeRoot);   

			//HTML Header
			m_strHTML+=R2H_GetHTMLHeader();

			//Create html main body 
			R2H_CreateHTMLElements(strRTFCode);   
			//Get HTML main body as string
			string strHTMLText=R2H_GetHTMLElements(); //strHTMLText);

			m_strHTML+="    "+strHTMLText+"\r\n";

			//HTML Footer
			m_strHTML+=R2H_GetHTMLFooter();
			/*
#if DEBUG
			if (m_strHTML!=string.Empty)
			{
				Form frm=new Form();
				TreeView tv=new TreeView();
				frm.Controls.Add(tv);
				tv.Visible=true;
				tv.Dock=DockStyle.Fill;
				tv.Nodes.Add(NodeRoot);
				tv.ExpandAll();
				frm.Show();
			}
#endif
			*/
			return m_strHTML;
		}

		#region Header & Footer Html

		// Формируем заголовок
		private string R2H_GetHTMLHeader()
		{
			StringBuilder strHTMLHeader=new StringBuilder();
			//strHTMLHeader.Append("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//DE\" \"http://www.w3.org/TR/html4/loose.dtd\">\r\n");
			strHTMLHeader.Append("<html>\r\n");
			strHTMLHeader.Append("  <head>\r\n");
			strHTMLHeader.Append("		<meta http-equiv=\"Content-Type\" content=\"text/html; charset=windows-"+m_strCharset+"\">\r\n");
			strHTMLHeader.Append("		<meta http-equiv=\"CopyRight\" content=\"text/html; autor="+m_Comment+"\">\r\n");
			strHTMLHeader.Append("    <title>"+m_strTitle+"</title>\r\n");
			strHTMLHeader.Append("    <base href='" + Environment.CurrentDirectory+ "'/>");
			strHTMLHeader.Append("  </head>\r\n");
			strHTMLHeader.Append("  <body>\r\n");
			return strHTMLHeader.ToString();
		}
		// Формируем Footer
		private string R2H_GetHTMLFooter()
		{
			StringBuilder strHTMLFooter=new StringBuilder();
			strHTMLFooter.Append("  </body>\r\n");
			strHTMLFooter.Append("</html>\r\n");
			return strHTMLFooter.ToString();
		}

		#endregion --Header & Footer Html

		string R2H_GetRTFTag(string strRTFSource, int lPos)
		{
			//Initializing
			StringBuilder strTag=new StringBuilder();
			Debug.Assert(lPos<strRTFSource.Length); //lPos is POS(\) within strRTFSource
			Debug.Assert(strRTFSource[lPos]=='\\');
			int nCnt=0;

			//Starting from lPos, we say everything is an rtf element until \ or blank or { occours
			for (int iStrPos=lPos;iStrPos<strRTFSource.Length;iStrPos++) 
			{
				if (iStrPos==lPos) 
					continue; //(we do not want the backslash (\) itself
				string strChTest=strRTFSource[iStrPos].ToString();
				int seek=strChTest.IndexOfAny(new char[]{' ','{','}','\\','\r'});
				if (seek!=-1)  //strChTest.SpanIncluding(" {}\\\r")!=""
					break; //designator terminated
				if ((strTag.Length>=3) && (strTag.ToString()==@"'"))
					break;
				strTag.Append(strChTest);
				nCnt++;
			}
	 
			return strTag.ToString();
		}
		void R2H_SetMetaData(ref CRTFNode NodeRoot) //CRTF_HTMLConverter::
		{
			//Initializing
			string strRTFSource = NodeRoot.m_strThisCode;

			//Go thru RTF main string's global data
			for (int iStrPos=0;iStrPos<strRTFSource.Length;iStrPos++)
			{
				string strChTest=strRTFSource[iStrPos].ToString();
				if (strChTest==@"\")
				{
					string strTag=R2H_GetRTFTag(strRTFSource, iStrPos);
					string strTestTag;
	         
					strTestTag="ansicpg";
					if ((strTag.Length>=strTestTag.Length) && (strTag.Substring(0,strTestTag.Length)==strTestTag))
					{
						//добавляем строку кодовой страницы
						m_strCharset = strTag.Remove(0, strTestTag.Length);
					}

					iStrPos+=strTag.Length;
					if (((iStrPos+1)<strRTFSource.Length) && (strRTFSource[iStrPos+1]==' '))
						iStrPos++; //Ignore Blank after Tag
				}
				else 
				{
					//Normal character
				}
			} //loop thru string   

			//Go thru 1st-level-nodes
			for(int iRTFNodes=0;iRTFNodes<NodeRoot.Nodes.Count;iRTFNodes++)
			{
				//Color table
				if (((CRTFNode)NodeRoot.Nodes[iRTFNodes]).m_strName=="colortbl")
				{
					string strColorTbl=((CRTFNode)NodeRoot.Nodes[iRTFNodes]).m_strThisCode;
					strColorTbl=strColorTbl.Remove(0,((CRTFNode)NodeRoot.Nodes[iRTFNodes]).m_strName.Length+1); //+1=leading \ (backslash)
					//Palette entries are separated with semicolon ;
					ArrayList arrStrColors=new ArrayList();	//CStringArray arrStrColors;
					arrStrColors.Add(strColorTbl);					//StringToArray(strColorTbl, arrStrColors);
					for (int iColor=0;iColor<arrStrColors.Count;iColor++)
					{
						//RGB values within palette entry are \redXXX\greenXXX\blueXXX
						int r=0,g=0,b=0;
						string strColorEntry=((string)arrStrColors[iColor]).Trim();
						if (strColorEntry.Length>0)
						{
							//Loop thru base colors (r,g,b) and set them
							//CStringArray arrStrRGBs;
							ArrayList arrStrRGBs=new ArrayList();
							R2H_GetRTFTags(strColorEntry, ref arrStrRGBs);
							Debug.Assert(arrStrRGBs.Count==3); //RTF must contain exactly 3 entries for red/green/blue
							for (int iBaseColor=0;iBaseColor<arrStrRGBs.Count;iBaseColor++) 
							{
								string strBaseColor=(string)arrStrRGBs[iBaseColor];
								string strTestBaseColor="red";
								if ((strBaseColor.Length>=strTestBaseColor.Length) && (strBaseColor.Substring(0,strTestBaseColor.Length)==strTestBaseColor))
								{ 
									strBaseColor=strBaseColor.Remove(0, strTestBaseColor.Length);
									r=int.Parse(strBaseColor);
								}
								strTestBaseColor="green";
								if ((strBaseColor.Length>=strTestBaseColor.Length) && (strBaseColor.Substring(0,strTestBaseColor.Length)==strTestBaseColor))
								{ 
									strBaseColor=strBaseColor.Remove(0, strTestBaseColor.Length);
									g=int.Parse(strBaseColor);
								}
								strTestBaseColor="blue";
								if ((strBaseColor.Length>=strTestBaseColor.Length) && (strBaseColor.Substring(0,strTestBaseColor.Length)==strTestBaseColor))
								{ 
									strBaseColor=strBaseColor.Remove(0, strTestBaseColor.Length);
									b=int.Parse(strBaseColor);
								}
							}
						}
						Color COLORREF =Color.FromArgb(r,g,b); 
						m_arrColors.Add(COLORREF);
					}
					continue;
				}
				//Font Table
				if (((CRTFNode)NodeRoot.Nodes[iRTFNodes]).m_strThisCode=="fonttbl") //m_strName
				{
					for(int iFontNodes=0;iFontNodes<NodeRoot.Nodes[iRTFNodes].Nodes.Count;iFontNodes++)
					{
						string strFontName=((CRTFNode)NodeRoot.Nodes[iRTFNodes].Nodes[iFontNodes]).m_strName;
						string strFont=((CRTFNode)NodeRoot.Nodes[iRTFNodes].Nodes[iFontNodes]).m_strPlain;
						Debug.Assert((strFontName.Length>=2) && (strFontName.Substring(1)=="f")); //No valid RTF
						Debug.Assert(strFont.Length>0);
						strFont=strFont.Trim();
						strFont.Replace(';',' ');
						//m_mapFontNames.SetAt(strFontName, strFont);            
						int ps =m_mapFontNames.IndexOf(strFontName);
						if (ps!=-1)
							m_mapFontNames[ps]= strFont;
					} //for-each-font
					continue;
				} //if font-table
			} //for each 1st-level-node
		}

		
		#endregion
		void R2H_GetRTFTags(string strRTFSource, ref ArrayList arrTgt) //CRTF_HTMLConverter::
		{
			//Go thru RTF main string
			for (int iStrPos=0;iStrPos<strRTFSource.Length;iStrPos++) 
			{
				string strChTest=strRTFSource[iStrPos].ToString();
				if (strChTest==@"\") 
				{
					string strTag=R2H_GetRTFTag(strRTFSource, iStrPos);
					arrTgt.Add(strTag);
					iStrPos+=strTag.Length;
					if (((iStrPos+1)<strRTFSource.Length) && (strRTFSource[iStrPos+1]==' '))
						iStrPos++; //Ignore Blank after Tag
				}
			} //loop thru string
		}
		CHTMLElement createAttrib(THTMLNodeType type,string text)
		{
			CHTMLElement ret = new CHTMLElement();
			ret.m_enNodeType=type;
			ret.m_strNodeText=text;
			return ret;
		}
		bool LeftFromString(ref string tag, string test)
		{
			if (tag==null || test==null)
				return false;
			else
				return (tag.Length>=test.Length) && (tag.Substring(0,test.Length)==test);
		}
		void R2H_InterpretTag(string strRTFTag) //CRTF_HTMLConverter::
		{
			string strTestTag=string.Empty;   
			CHTMLElement pElement=null;

			#region Однозначные операторы

			switch(strRTFTag)
			{
				case "rtf1":
					return;
				case "b":
					pElement=createAttrib(THTMLNodeType.c_nodHTMLBegin,	"b");
					break;
				case "b0":
					pElement=createAttrib(THTMLNodeType.c_nodHTMLBegin,	"b"); 
					break;
				case "i":
					pElement=createAttrib(THTMLNodeType.c_nodHTMLBegin,	"i"); 
					break;
				case "i0":
					pElement=createAttrib(THTMLNodeType.c_nodHTMLEnd,		"i");	
					break;
				case "ul":
					pElement=createAttrib(THTMLNodeType.c_nodHTMLBegin,	"u");	
					break;
				case "ulnone":
					pElement=createAttrib(THTMLNodeType.c_nodHTMLEnd,		"u");	
					break;
				case "title":
					pElement=createAttrib(THTMLNodeType.c_nodComment,		"title");	
					break;
				case "author":
					pElement=createAttrib(THTMLNodeType.c_nodComment,		"author");
					break;
				case "subject":	
					pElement=createAttrib(THTMLNodeType.c_nodComment,		"subject");
					break;
				case "company":	
					pElement=createAttrib(THTMLNodeType.c_nodComment,		"company");
					break;
				case "manager":	
					pElement=createAttrib(THTMLNodeType.c_nodComment,		"manager");
					break;
				case "operator":
					pElement=createAttrib(THTMLNodeType.c_nodComment,		"operator");
					break;
				case "category":
					pElement=createAttrib(THTMLNodeType.c_nodComment,		"category");
					break;
				case "comment":	
					pElement=createAttrib(THTMLNodeType.c_nodComment,		"comment");
					break;
				case "keywords":
					pElement=createAttrib(THTMLNodeType.c_nodComment,		"keywords");
					break;
				case "creatim":	
					pElement=createAttrib(THTMLNodeType.c_nodComment,		"createtime");
					break;
				case "time":
					pElement=createAttrib(THTMLNodeType.c_nodComment,		"time");
					break;
				case "protect":
					pElement=createAttrib(THTMLNodeType.c_nodHTMLBegin,	"protected");
					break;
				case "protect0":
					pElement=createAttrib(THTMLNodeType.c_nodHTMLEnd,		"protected");
					break;
				case "v": //unvisible
					pElement=createAttrib(THTMLNodeType.c_nodHTMLBegin,	"pre");
					break;
				case "v0":
					pElement=createAttrib(THTMLNodeType.c_nodHTMLEnd,	  "pre");
					break;

				case "par":			
					strTestTag="par";
					string strSpecialChar=strRTFTag.Remove(0, strTestTag.Length);
					int lLastUnclosedPStart=-1;
					//Look if we first must close paragraph
					for (int iLastElements=m_arrHTMLElements.Count-1;iLastElements>=0;iLastElements--) 
					{
						CHTMLElement pElementTest = (CHTMLElement)m_arrHTMLElements[iLastElements];
						if (pElementTest.m_strNodeText=="p")
						{
							if (pElementTest.m_enNodeType==THTMLNodeType.c_nodHTMLEnd)
								break; //everything is OK
							if ((pElementTest.m_enNodeType==THTMLNodeType.c_nodHTMLBegin)) 
							{
								lLastUnclosedPStart=iLastElements;
								break; //everything is OK
							}
						}
					}
					if (lLastUnclosedPStart>=0) 
					{
						//Look if there is no text between last <p> and this <p-end> (e.g. <p></p>)
						//HTML does then not display a linefeed, therefore make it to <p>&nbsp;</p>
						bool bLastParaEmpty=true;
						for (int iLastPara=lLastUnclosedPStart;iLastPara<m_arrHTMLElements.Count;iLastPara++) 
						{
							CHTMLElement pElementTest = (CHTMLElement)m_arrHTMLElements[iLastPara];
							if (pElementTest.m_enNodeType==THTMLNodeType.c_nodText) 
							{
								if ((pElementTest.m_strNodeText!="")&&
									(pElementTest.m_strNodeText!="\r")&&
									(pElementTest.m_strNodeText!="\n")&&
									(pElementTest.m_strNodeText!="\r\n")&&
									(pElementTest.m_strNodeText!="b"))
								{
									bLastParaEmpty = false;
								}
							}
						}
						if (bLastParaEmpty)
						{ //Insert modified blank (see above)
							CHTMLElement pElementBlank = new CHTMLElement();
							pElementBlank.m_enNodeType=THTMLNodeType.c_nodText;
							pElementBlank.m_strNodeText = "&nbsp;";
							m_arrHTMLElements.Add(pElementBlank);
						}
						//Insert Closing </p>
						CHTMLElement pElementClose = new CHTMLElement();
						pElementClose.m_enNodeType=THTMLNodeType.c_nodHTMLEnd;
						pElementClose.m_strNodeText = "p";
						m_arrHTMLElements.Add(pElementClose);
					}
					pElement=new CHTMLElement();
					//Add paragraph tag (<p>
					pElement.m_enNodeType=THTMLNodeType.c_nodHTMLBegin;
					pElement.m_strNodeText = "p";
				return;
			}
			#endregion

			if (pElement!=null)
				return;
			pElement=new CHTMLElement();
			bool wordOk=true;
			#region Special character (umlaut)

			strTestTag="'";
			if (LeftFromString(ref strRTFTag,strTestTag) && wordOk)
			{   
				string strSpecialChar=strRTFTag.Remove(0, strTestTag.Length);
				if (strSpecialChar.Length==2) //RTF (must be 2-digit hex code)
				{
					strSpecialChar=strSpecialChar.Substring(0,2);
					pElement.m_enNodeType=THTMLNodeType.c_nodText;
					string strHex=Converters.fromHex(strSpecialChar);
					pElement.m_strNodeText = strHex; //"&#x"+strSpecialChar+";";
				}
				wordOk=false;
			}
			#endregion
			#region Paragraph Alignment

			strTestTag="q";
			if (LeftFromString(ref strRTFTag,strTestTag) && wordOk)
			{
				//Get RTF alignment
				string strAlignHTML=string.Empty;
				pElement.m_enNodeType=THTMLNodeType.c_nodHTMLBegin;
				pElement.m_strNodeText= "font";
				string strAlignRTF = strRTFTag.Remove(0, strTestTag.Length);

				Debug.Assert(strAlignRTF.Length==1); //Invalid RTF
				//Convert RTF options to HTML options
				switch(strAlignRTF)
				{
					case "l": strAlignHTML="left";	break;
					case "r":	strAlignHTML="right";		break;
					case "c": strAlignHTML="center";	break;
					default: break; //unsupported
				}
				//Find last paragraph
				int lLastParaStart=-1;
				for (int iLastElements=m_arrHTMLElements.Count-1;iLastElements>=0;iLastElements--)
				{
					CHTMLElement pElementTest = (CHTMLElement)m_arrHTMLElements[iLastElements];
					if ((pElementTest.m_enNodeType==THTMLNodeType.c_nodHTMLBegin) && (pElementTest.m_strNodeText=="p")) 
					{
						lLastParaStart=iLastElements;
						break; //everything is OK
					}
				}
				if ((lLastParaStart>=0) && (strAlignHTML!="")) 
				{
					CHTMLElement pElementPara = (CHTMLElement)m_arrHTMLElements[lLastParaStart];
					//pElementPara.m_mapParams.SetAt("align", "\""+strAlignHTML+"\""); //SetAt("align", "\""+strAlignHTML+"\"")
					string val="\""+strAlignHTML+"\"";
					int key=pElementPara.m_mapParams.IndexOfKey("align");
					if (key!=-1)
						pElementPara.m_mapParams.Add("align",val);
					else
						pElementPara.m_mapParams[key]=val;
				}
				wordOk=false;
			}
			#endregion
			#region font color

			strTestTag="cf";
			if (LeftFromString(ref strRTFTag,strTestTag) && wordOk)
			{   
				pElement.m_enNodeType=THTMLNodeType.c_nodHTMLBegin;
				pElement.m_strNodeText= "font";
				string strActColor = strRTFTag.Remove(0, strTestTag.Length);
				Debug.Assert(strActColor.Length>0); //Invalid RTF

				int lActColor=int.Parse(strActColor);
				Debug.Assert(lActColor<m_arrColors.Count); //Color not in Colortable !
				if (lActColor<m_arrColors.Count) 
				{
					Color clr=(Color)m_arrColors[lActColor];
					//int r=0,g=0,b=0;
					//r=GetRValue(ref);
					//g=GetGValue(ref);
					//b=GetBValue(ref);
					//strHTMLColor.Format("#%02x%02x%02x",r,g,b);
					m_strActFontColor = System.Drawing.ColorTranslator.ToHtml(clr);;
				}
				wordOk=false;
			}
			#endregion

			#region font size

			strTestTag="fs";
			if (LeftFromString(ref strRTFTag,strTestTag) && wordOk)
			{   
				pElement.m_enNodeType=THTMLNodeType.c_nodHTMLBegin;
				pElement.m_strNodeText= "font";
				m_strActFontSize = strRTFTag.Remove(0, strTestTag.Length);
				Debug.Assert(m_strActFontSize.Length>0); //Invalid RTF
				//m_strActFontSize=LongToString(StringToLong(m_strActFontSize)/2); //RTF stores the doubled font size
				m_strActFontSize=Convert.ToString(int.Parse(m_strActFontSize)/2); //RTF stores the doubled font size
				wordOk=false;
			}
			#endregion

			#region font name

			strTestTag="f";  //f+number
			//(strRTFTag.Mid(1).SpanIncluding("01234567890")==strRTFTag.Mid(1))) 
			int seek=strRTFTag.Substring(0,2).IndexOfAny(new char[]{'0','1','2','3','4','5','6','7','8','9','0'},1);
			if (LeftFromString(ref strRTFTag,strTestTag)  && wordOk && (seek!=-1)) 
			{   
				string strActFontDsgn = strRTFTag;
				pElement.m_enNodeType=THTMLNodeType.c_nodHTMLBegin;
				pElement.m_strNodeText= "font";
				Debug.Assert(strActFontDsgn.Length>0); //Invalid RTF
				//string strActFontName;
				//bool bFound=false;
				int bFound=m_mapFontNames.IndexOf(m_strActFontName);
				//Debug.Assert(bFound==-1); //Font not found in font table, don't change font
				if (bFound!=-1) 
					m_mapFontNames[bFound]=m_strActFontName;
				else
					m_mapFontNames.Add(m_strActFontName);
				wordOk=false;
			}
			#endregion
			#region New font tag ?
			if ( !wordOk && (pElement.m_enNodeType==THTMLNodeType.c_nodHTMLBegin) && (pElement.m_strNodeText=="font")) 
			{
				bool bMustClose=false;
				//Look if we first must close paragraph
				for (int iLastElements=m_arrHTMLElements.Count-1;iLastElements>=0;iLastElements--) 
				{
					CHTMLElement pElementTest = (CHTMLElement)m_arrHTMLElements[iLastElements];
					if ((pElementTest.m_enNodeType==THTMLNodeType.c_nodHTMLEnd) && (pElementTest.m_strNodeText=="font")) 
						break; //everything is OK
					if ((pElementTest.m_enNodeType==THTMLNodeType.c_nodHTMLBegin) && (pElementTest.m_strNodeText=="font")) 
					{
						bMustClose=true;
						break; //everything is OK
					}
				}
				if (bMustClose) 
				{
					//Insert Closing </p>
					CHTMLElement pElementClose = new CHTMLElement();
					pElementClose.m_enNodeType=THTMLNodeType.c_nodHTMLEnd;
					pElementClose.m_strNodeText = "font";
					m_arrHTMLElements.Add(pElementClose);
				}
				//Set font tag options
				//pElement.m_mapParams.SetAt("color", "\""+m_strActFontColor+"\"");
				string key="color", val="\""+m_strActFontColor+"\"";;
				int index=pElement.m_mapParams.IndexOfKey(key);
				if (index==-1)
					pElement.m_mapParams.Add(key,val);
				else
					pElement.m_mapParams[key]=val;
				//pElement.m_mapParams.SetAt("style", "\"font-size: "+m_strActFontSize+"pt; font-family:"+m_strActFontName+";\"");
				key="style";
				val="\"font-size: "+m_strActFontSize+"pt; font-family:"+m_strActFontName+";\"";

				index =pElement.m_mapParams.IndexOfKey(key);
				if (index==-1)
					pElement.m_mapParams.Add(key,val);
				else
					pElement.m_mapParams[key]=val;
			}
			#endregion
			#region old Interpret
			#region Char attributes
			/*
			//Char attributes
			if (strRTFTag=="b")
			{
				pElement.m_enNodeType= THTMLNodeType.c_nodHTMLBegin;
				pElement.m_strNodeText = "b";
			}
			else if (strRTFTag=="b0")
			{
				pElement.m_enNodeType=THTMLNodeType.c_nodHTMLEnd;
				pElement.m_strNodeText = "b";
			}
			else if (strRTFTag=="i")
			{
				pElement.m_enNodeType=THTMLNodeType.c_nodHTMLBegin;
				pElement.m_strNodeText = "i";
			} 
			else if (strRTFTag=="i0")
			{
				pElement.m_enNodeType=THTMLNodeType.c_nodHTMLEnd;
				pElement.m_strNodeText = "i";
			}
			else if (strRTFTag=="ul")
			{
				pElement.m_enNodeType=THTMLNodeType.c_nodHTMLBegin;
				pElement.m_strNodeText = "u";
			}
			else if (strRTFTag=="ulnone")
			{
				pElement.m_enNodeType=THTMLNodeType.c_nodHTMLEnd;
				pElement.m_strNodeText = "u";
			} 
			*/
			#endregion
			#region Special character (umlaut)
			/*
			//Special character (umlaut)
			strTestTag="'";
			if ((pElement.m_enNodeType==THTMLNodeType.c_nodInvalid) && (strRTFTag.Length>=strTestTag.Length) && (strRTFTag.Substring(0,strTestTag.Length)==strTestTag))
			{   
				string strSpecialChar=strRTFTag.Remove(0, strTestTag.Length);
				if (strSpecialChar.Length==2) //RTF (must be 2-digit hex code)
				{
					strSpecialChar=strSpecialChar.Substring(0,2);
					pElement.m_enNodeType=THTMLNodeType.c_nodText;
					string strHex=Converters.fromHex(strSpecialChar);
					pElement.m_strNodeText = strHex; //"&#x"+strSpecialChar+";";
				}
			}
			//Paragraph Tag
			if ((pElement.m_enNodeType==THTMLNodeType.c_nodInvalid) && (strRTFTag=="par"))
			{
				int lLastUnclosedPStart=-1;
				//Look if we first must close paragraph
				for (int iLastElements=m_arrHTMLElements.Count-1;iLastElements>=0;iLastElements--) 
				{
					CHTMLElement pElementTest = (CHTMLElement)m_arrHTMLElements[iLastElements];
					if (pElementTest.m_strNodeText=="p")
					{
						if (pElementTest.m_enNodeType==THTMLNodeType.c_nodHTMLEnd)
							break; //everything is OK
						if ((pElementTest.m_enNodeType==THTMLNodeType.c_nodHTMLBegin)) 
						{
							lLastUnclosedPStart=iLastElements;
							break; //everything is OK
						}
					}
				}
				if (lLastUnclosedPStart>=0) 
				{
					//Look if there is no text between last <p> and this <p-end> (e.g. <p></p>)
					//HTML does then not display a linefeed, therefore make it to <p>&nbsp;</p>
					bool bLastParaEmpty=true;
					for (int iLastPara=lLastUnclosedPStart;iLastPara<m_arrHTMLElements.Count;iLastPara++) 
					{
						CHTMLElement pElementTest = (CHTMLElement)m_arrHTMLElements[iLastPara];
						if (pElementTest.m_enNodeType==THTMLNodeType.c_nodText) 
						{
							if ((pElementTest.m_strNodeText!="")&&
								(pElementTest.m_strNodeText!="\r")&&
								(pElementTest.m_strNodeText!="\n")&&
								(pElementTest.m_strNodeText!="\r\n")&&
								(pElementTest.m_strNodeText!="b"))
							{
								bLastParaEmpty = false;
							}
						}
					}
					if (bLastParaEmpty)
					{ //Insert modified blank (see above)
						CHTMLElement pElementBlank = new CHTMLElement();
						pElementBlank.m_enNodeType=THTMLNodeType.c_nodText;
						pElementBlank.m_strNodeText = "&nbsp;";
						m_arrHTMLElements.Add(pElementBlank);
					}
					//Insert Closing </p>
					CHTMLElement pElementClose = new CHTMLElement();
					pElementClose.m_enNodeType=THTMLNodeType.c_nodHTMLEnd;
					pElementClose.m_strNodeText = "p";
					m_arrHTMLElements.Add(pElementClose);
				}
				//Add paragraph tag (<p>
				pElement.m_enNodeType=THTMLNodeType.c_nodHTMLBegin;
				pElement.m_strNodeText = "p";
			}
			else
			{
				; //Unknown RTF tag, just ignore
			}
			*/
			#endregion
			#region Old Paragraph Alignment
			/*
			strTestTag="q";
			if ((pElement.m_enNodeType==THTMLNodeType.c_nodInvalid) && (strRTFTag.Length>=strTestTag.Length) && (strRTFTag.Substring(0,strTestTag.Length)==strTestTag)) 
			{   
				//Get RTF alignment
				string strAlignRTF, strAlignHTML=string.Empty;
				pElement.m_enNodeType=THTMLNodeType.c_nodHTMLBegin;
				pElement.m_strNodeText= "font";
				strAlignRTF = strRTFTag.Remove(0, strTestTag.Length);

				Debug.Assert(strAlignRTF.Length==1); //Invalid RTF
				//Convert RTF options to HTML options
				if (strAlignRTF=="l") 
				{
					strAlignHTML="left";
				} 
				else if (strAlignRTF=="r") 
				{
					strAlignHTML="right";
				} 
				else if (strAlignRTF=="c") 
				{
					strAlignHTML="center";
				} 
				else 
				{
					; //unsupported
				}
				//Find last paragraph
				int lLastParaStart=-1;
				for (int iLastElements=m_arrHTMLElements.Count-1;iLastElements>=0;iLastElements--)
				{
					CHTMLElement pElementTest = (CHTMLElement)m_arrHTMLElements[iLastElements];
					if ((pElementTest.m_enNodeType==THTMLNodeType.c_nodHTMLBegin) && (pElementTest.m_strNodeText=="p")) 
					{
						lLastParaStart=iLastElements;
						break; //everything is OK
					}
				}
				if ((lLastParaStart>=0) && (strAlignHTML!="")) 
				{
					CHTMLElement pElementPara = (CHTMLElement)m_arrHTMLElements[lLastParaStart];
					//pElementPara.m_mapParams.SetAt("align", "\""+strAlignHTML+"\""); //SetAt("align", "\""+strAlignHTML+"\"")
					string val="\""+strAlignHTML+"\"";
					int key=pElementPara.m_mapParams.IndexOfKey("align");
					if (key!=-1)
						pElementPara.m_mapParams.Add("align",val);
					else
						pElementPara.m_mapParams[key]=val;
				}
			}
			*/
			#endregion
			#region Old font color
			/*
			//font color
			strTestTag="cf";
			if ((pElement.m_enNodeType==THTMLNodeType.c_nodInvalid) && (strRTFTag.Length>=strTestTag.Length) && (strRTFTag.Substring(0,strTestTag.Length)==strTestTag))
			{   
				pElement.m_enNodeType=THTMLNodeType.c_nodHTMLBegin;
				pElement.m_strNodeText= "font";
				string strActColor = strRTFTag.Remove(0, strTestTag.Length);
				Debug.Assert(strActColor.Length>0); //Invalid RTF

				int lActColor=int.Parse(strActColor);
				Debug.Assert(lActColor<m_arrColors.Count); //Color not in Colortable !
				if (lActColor<m_arrColors.Count) 
				{
					Color clr=(Color)m_arrColors[lActColor];
					//int r=0,g=0,b=0;
					//r=GetRValue(ref);
					//g=GetGValue(ref);
					//b=GetBValue(ref);
					//strHTMLColor.Format("#%02x%02x%02x",r,g,b);
					m_strActFontColor = System.Drawing.ColorTranslator.ToHtml(clr);;
				}
			}
			*/
			#endregion
			#region Old font size
			/*
			//font size
			strTestTag="fs";
			if ((pElement.m_enNodeType==THTMLNodeType.c_nodInvalid) && (strRTFTag.Length>=strTestTag.Length) && (strRTFTag.Substring(0,strTestTag.Length)==strTestTag)) 
			{   
				pElement.m_enNodeType=THTMLNodeType.c_nodHTMLBegin;
				pElement.m_strNodeText= "font";
				m_strActFontSize = strRTFTag.Remove(0, strTestTag.Length);
				Debug.Assert(m_strActFontSize.Length>0); //Invalid RTF
				//m_strActFontSize=LongToString(StringToLong(m_strActFontSize)/2); //RTF stores the doubled font size
				m_strActFontSize=Convert.ToString(int.Parse(m_strActFontSize)/2); //RTF stores the doubled font size
			}
			*/
			#endregion
			#region Old font name
			/*
			//font name
			strTestTag="f";  //f+number
			//(strRTFTag.Mid(1).SpanIncluding("01234567890")==strRTFTag.Mid(1))) 
			int seek=strRTFTag.IndexOfAny(new char[]{'0','1','2','3','4','5','6','7','8','9','0'},1);
			if ((pElement.m_enNodeType==THTMLNodeType.c_nodInvalid) && (strRTFTag.Length>=strTestTag.Length) && (strRTFTag.Substring(0,strTestTag.Length)==strTestTag)
				&& (seek!=-1)) 
			{   
				string strActFontDsgn = strRTFTag;
				pElement.m_enNodeType=THTMLNodeType.c_nodHTMLBegin;
				pElement.m_strNodeText= "font";
				Debug.Assert(strActFontDsgn.Length>0); //Invalid RTF
				//string strActFontName;
				//bool bFound=false;
				int bFound=m_mapFontNames.IndexOf(m_strActFontName);
				Debug.Assert(bFound==-1); //Font not found in font table, don't change font
				if (bFound!=-1) 
					m_mapFontNames[bFound]=m_strActFontName;
				else
					m_mapFontNames.Add(m_strActFontName);
			}
			*/
			#endregion
			#region Old New font tag ?
			/*
			//New font tag ?
			if ((pElement.m_enNodeType==THTMLNodeType.c_nodHTMLBegin) && (pElement.m_strNodeText=="font")) 
			{
				bool bMustClose=false;
				//Look if we first must close paragraph
				for (int iLastElements=m_arrHTMLElements.Count-1;iLastElements>=0;iLastElements--) 
				{
					CHTMLElement pElementTest = (CHTMLElement)m_arrHTMLElements[iLastElements];
					if ((pElementTest.m_enNodeType==THTMLNodeType.c_nodHTMLEnd) && (pElementTest.m_strNodeText=="font")) 
						break; //everything is OK
					if ((pElementTest.m_enNodeType==THTMLNodeType.c_nodHTMLBegin) && (pElementTest.m_strNodeText=="font")) 
					{
						bMustClose=true;
						break; //everything is OK
					}
				}
				if (bMustClose) 
				{
					//Insert Closing </p>
					CHTMLElement pElementClose = new CHTMLElement();
					pElementClose.m_enNodeType=THTMLNodeType.c_nodHTMLEnd;
					pElementClose.m_strNodeText = "font";
					m_arrHTMLElements.Add(pElementClose);
				}
				//Set font tag options
				//pElement.m_mapParams.SetAt("color", "\""+m_strActFontColor+"\"");
				string key="color", val="\""+m_strActFontColor+"\"";;
				int index=pElement.m_mapParams.IndexOfKey(key);
				if (index==-1)
					pElement.m_mapParams.Add(key,val);
				else
					pElement.m_mapParams[key]=val;
				//pElement.m_mapParams.SetAt("style", "\"font-size: "+m_strActFontSize+"pt; font-family:"+m_strActFontName+";\"");
				key="style";
				val="\"font-size: "+m_strActFontSize+"pt; font-family:"+m_strActFontName+";\"";

				index =pElement.m_mapParams.IndexOfKey(key);
				if (index==-1)
					pElement.m_mapParams.Add(key,val);
				else
					pElement.m_mapParams[key]=val;
			}
			*/
			#endregion

			#endregion
			if (pElement.m_enNodeType!=THTMLNodeType.c_nodInvalid) 
				m_arrHTMLElements.Add(pElement);
		}

		//! Gets the created HTML elements as HTML text
		string R2H_GetHTMLElements() //CRTF_HTMLConverter::
		{
			StringBuilder ret=new StringBuilder(); //strHTML="";
			//Loop thru all HTML elements
			for (int iElem=0;iElem<m_arrHTMLElements.Count;iElem++) 
			{
				CHTMLElement pElem = (CHTMLElement) m_arrHTMLElements[iElem];
				if(pElem!=null)
				{
					if (pElem.m_enNodeType==THTMLNodeType.c_nodHTMLBegin)
					{
						//HTML element open tag
						ret.Append("<");
						ret.Append(pElem.m_strNodeText);
						//HML element parameters (<font param1="test" param2="hugo">
						//POSITION pos;
						/*
						int pos=pElem.m_mapParams.GetStartPosition();
						while (pos!=0) 
						{
							string strKey, strValue;
							pElem.m_mapParams.GetNextAssoc(pos, strKey, strValue);
							ret.Append(" "+strKey+" = "+strValue);
						}
						*/
						for (int index=0;index<pElem.m_mapParams.Count;index++)
						{
							string strKey=(string)pElem.m_mapParams.GetKey(index);
							string strVal=(string)pElem.m_mapParams[strKey];
							if (strKey!="color" && strVal!="\"#000000\"")
								ret.Append(" "+strKey+" = "+strVal);
						}
						ret.Append(">");
					}
					else if (pElem.m_enNodeType==THTMLNodeType.c_nodHTMLEnd)
					{
						ret.Append("</"+pElem.m_strNodeText+">");
					}
					else if (pElem.m_enNodeType==THTMLNodeType.c_nodText)
					{

						if (LeftFromString(ref pElem.m_strNodeText,constHTTP))
						{
							//это HTTP из бывшего RTF - разбираем и заменяем
							string[] str=pElem.m_strNodeText.Split('&');
							string path=string.Empty,name=string.Empty,create=string.Empty;int place=0,type=0,code=0;
							try
							{
								for (int i=0;i< str.Length;i++)
								{
									if(str[i].Length>5)
									{
										if (str[i].Substring(0,5)=="path=" && path==string.Empty)
											//записываем путь
											path=str[i].Substring(5,str[i].Length-5);
										else if (str[i].Substring(0,6)=="place=" && place==0)
											//записываем код
											place=CASTools.ConvertToInt32Or0(str[i].Substring(6,str[i].Length-6));
										else if (str[i].Substring(0,5)=="code=" && code==0)
											//записываем код
											code=CASTools.ConvertToInt32Or0(str[i].Substring(5,str[i].Length-5));
										else if(str[i].Substring(0,5)=="type=" && type==0)
											//записываем код
											type=CASTools.ConvertToInt32Or0(str[i].Substring(5,str[i].Length-5));
										else if(str[i].Substring(0,5)=="name=" && name==string.Empty)
											name=Converters.fromBase64(str[i].Substring(5,str[i].Length-5));
										else if(str[i].Length>25 && str[i].Substring(0,25)=="DateTimeLabelUniqueValue=" && create==string.Empty)
										{
											create=str[i].Substring(25,str[i].Length-25).Trim();
											if (create.Length==13)
												create="Ссылка создана "+create.Substring(0,2)+"."+create.Substring(2,2)+"."+create.Substring(4,2)+" "+create.Substring(7,2)+":"+create.Substring(9,2)+":"+create.Substring(11,2);
										}
									}
								}
								ret.Append(" <a href='?path="+path+"&place="+place+"&code="+code+"&type="+type+"' title='"+create+"'>"+name+"</a> ");
							}
							catch
							{
								ret.Append("<b>Error in parse a ["+pElem.m_strNodeText+"]</b");
							}
						}
						else
							ret.Append(pElem.m_strNodeText);
					}
					else if (pElem.m_enNodeType==THTMLNodeType.c_nodComment)
					{
						ret.Append("<!-- "+pElem.m_strNodeText+"-->\n");
					}
					else
					{
						Debug.Assert(false); //internal error (wrong html tag)
					}
				}
			}
			return ret.ToString();
		}

		void R2H_CreateHTMLElements(string strRTFSource) //CRTF_HTMLConverter::
		{
			//Go thru RTF main string
			string strCurrentText=string.Empty;
			for (int iStrPos=0;iStrPos<strRTFSource.Length;iStrPos++)
			{
				string strChTest=strRTFSource[iStrPos].ToString();
				if (strChTest==@"\")
				{
					//New tag
					if (strCurrentText.Length>0)
					{
						CHTMLElement pElement = new CHTMLElement();
						pElement.m_enNodeType=THTMLNodeType.c_nodText;
						pElement.m_strNodeText = strCurrentText;
						m_arrHTMLElements.Add(pElement);
						strCurrentText=string.Empty;
					}
					string strTag=R2H_GetRTFTag(strRTFSource, iStrPos);
					R2H_InterpretTag(strTag);         
					iStrPos+=strTag.Length;
					//string strNextTag=R2H_GetRTFTag(strRTFSource, iStrPos+1);

					if (((iStrPos+1)<strRTFSource.Length) && (strRTFSource[iStrPos+1]==' ')) 
						iStrPos++; //Ignore Blank after Tag
				} 
				else
				{
					//Normal character
					strCurrentText+=strChTest;
				}
			} //loop thru string

			//Add last text
			if (strCurrentText.Length>0)
			{
				CHTMLElement pElement = new CHTMLElement();
				pElement.m_enNodeType=THTMLNodeType.c_nodText;
				pElement.m_strNodeText = strCurrentText;
				m_arrHTMLElements.Add(pElement);
				//strCurrentText=string.Empty;
			}
		}

		CRTFNode R2H_BuildTree(string strSource, ref CRTFNode pNodeParent) //CRTF_HTMLConverter::CRTFNode CRTF_HTMLConverter::
		{
			//Initializing   
			string strName=string.Empty;
			CRTFNode nodeThis=new CRTFNode();
			//Extract Node's Name
			if ((strSource.Length>2) && (strSource.Substring(0,2)==@"{\"))
			{
				for (int iStrPos=2;iStrPos<strSource.Length;iStrPos++)
				{
					string strChTest=strSource[iStrPos].ToString();
					int seek=strChTest.IndexOfAny(new char[]{' ','{','}','\\','\r'}); //
					if (seek==-1) //strChTest.SpanIncluding(" {}\\\r")!="")
						break;
					else
						strName+=strChTest;
				}
			}
			else
			{
				//Invalid RTF Node. RTF Nodes must start with a { and then contain a \NAME identifier
				Debug.Assert(false);
				return nodeThis;
			}

			//Extract pure text - отрезаем начало и конец
			string strNodeText=strSource.Substring(1,strSource.Length-2);
			//strNodeText=strNodeText.Remove(0,1); //strNodeText.Delete(0,1);
			//strNodeTextstrNodeText.Remove(strNodeText.Length-1, 1); //strNodeText.Delete(strNodeText.Length)-1, 1);

			//Add node into tree
			CRTFNode nodeA=new CRTFNode();
			nodeA.m_strCode = strSource;
			nodeA.m_strName = strName;
			if (pNodeParent!=null)
				nodeThis = (CRTFNode)pNodeParent.Nodes[pNodeParent.Nodes.Add(nodeA)];
			else
				nodeThis = (CRTFNode)nodeA.Nodes[m_RTFTree.Nodes.Add(nodeA)];

			//Looking for children
			string strNodeNew=string.Empty,strThisCode=string.Empty ;
			int lLevel=0; //# Of opened {
			for (int iStrPos=0;iStrPos<strNodeText.Length;iStrPos++)
			{
				string strChTest=strNodeText[iStrPos].ToString();
				if (strChTest=="{")
				{
					//New element 
					if (lLevel==0)
						strNodeNew=string.Empty;
					//else - Nested Element, will be added during recurse
					lLevel++;
				}
				if (lLevel>0)
					strNodeNew+=strChTest;
				else
					strThisCode+=strChTest;
				if (strChTest=="}")
				{
					Debug.Assert(lLevel>0); //Invalid RTF, more closing } than opening ґ{
					lLevel--;
					if (lLevel==0) 
					{
						//Recurse (new Sub-Node (child) ready
						R2H_BuildTree(strNodeNew,ref nodeThis); //R2H_BuildTree(strNodeNew,&nodeThis);
					}  
					else {;} //Nested Element, will be added during recurse
				}
			} //loop thru string
			Debug.Assert(lLevel==0); //Invalid RTF, more opening { than closing }

			//Get the plain text (without \)
			string strPlain=string.Empty;
			for (int iStrPos=0;iStrPos<strNodeText.Length;iStrPos++)
			{
				string strChTest=strNodeText[iStrPos].ToString();
				if (strChTest==@"\")
				{
					string strTag=R2H_GetRTFTag(strNodeText, iStrPos);
					iStrPos+=strTag.Length;
					if (((iStrPos+1)<strNodeText.Length)&&(strNodeText[iStrPos+1]==' ')) 
						iStrPos++; //Ignore Blank after Tag
					else
						strPlain+=strChTest;
				}
			} //loop thru string

			nodeThis.m_strPlain=strPlain;
			nodeThis.m_strThisCode = strThisCode;
			return nodeThis;
		}
		#region Not used
		/*
		string operator << ( string os, CRTF_HTMLConverter conv )
		{
			//For streaming operations
			if (conv.m_enMode==CRTF_HTMLConverter::c_modRTF2HTML) 
				os = conv.m_strHTML;
			else 
				os = conv.m_strHTML;
			return os;
		}
		*/
		/*
		string operator >> ( string is, CRTF_HTMLConverter conv )
		{
			//For streaming operations
			CString strTemp;
			strTemp = is;
			//RTF->HTML
			if (conv.m_enMode==CRTF_HTMLConverter::c_modRTF2HTML)
			{
				conv.m_strRTF = strTemp;
				conv.ConvertRTF2HTML();
			}
				return is;
		}
		*/
		/*	
		void CHTMLElement() //CRTF_HTMLConverter::CHTMLElement::
		{
			m_enNodeType = THTMLNodeType.c_nodInvalid;
		}*/

		#endregion

		protected class CRTFNode : TreeNode
		{
			//private string mSstrName;
			private string mStrName; //!< Name of node (primary attribute/RTF Tag)
			public string m_strName //!< Name of node (primary attribute/RTF Tag)
			{
				get
				{
					return mStrName;
				}
				set
				{
					mStrName=value;
				}
			}
			private string mStrCode;
			public string m_strCode //!< The node's whole code (with sub-nodes)
			{
				get
				{
					return mStrCode;
				}
				set
				{
					mStrCode=value;
				}
			}
			private string mStrThisCode;
			public string m_strThisCode				//!< the nodes code (without sub-nodes)
			{
				get
				{
					return mStrThisCode;
				}
				set
				{
					mStrThisCode=value;
					this.Text=value;
				}
			}
			private string mStrPlain;
			public string m_strPlain //!< The nodes plain text (without sub-nodes and attributes/RTF Tags)
			{
				get
				{
					return mStrPlain;
				}
				set
				{
					mStrPlain=value;
				}
			}

			public CRTFNode():base()
			{
			}
			public new string Text
			{
				get
				{
					return base.Text;
				}
				set
				{
					if (value!=null)
						base.Text=value;
					else
						base.Text=string.Empty;
				}
			}
		}

		public enum THTMLNodeType
		{
			c_nodHTMLBegin,  //<b>
			c_nodHTMLEnd,    //</b>
			c_nodText,       //"this is a test>
			c_nodComment,    //"comment in headers (section meta)
			c_nodInvalid     //temporary (initialized) state, no such nodes are written
		}

		protected class CHTMLElement
		{
			public string m_strNodeText;
			public THTMLNodeType m_enNodeType;
			//CMapStringToString
			public SortedList m_mapParams; //!< Only relevant for m_enNodeType==c_nodHTMLBegin;
			public CHTMLElement()
			{
				m_mapParams=new SortedList();
				m_enNodeType=THTMLNodeType.c_nodInvalid;
			}
		}
	}
}
